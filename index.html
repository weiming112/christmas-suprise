<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Scrolling Christmas Surprise</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;700&display=swap" rel="stylesheet">
<style>
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }
  
  html {
    scroll-behavior: smooth;
    scroll-snap-type: y mandatory;
    overflow-y: scroll;
  }
  
  body {
    font-family: 'Inter', sans-serif;
    background: #0a0a0a;
    color: white;
    overflow-x: hidden;
  }
  
  section {
    min-height: 100vh;
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 80px 20px;
    position: relative;
    scroll-snap-align: start;
    scroll-snap-stop: always;
  }
  
  .text {
    max-width: 800px;
    font-size: clamp(2rem, 5vw, 3.5rem);
    font-weight: 500;
    line-height: 1.4;
  }
  
  .text span {
    display: inline-block;
    opacity: 0;
    transform: translateY(100px) rotateX(-90deg);
    filter: blur(10px);
    transition: all 0.8s cubic-bezier(0.16, 1, 0.3, 1);
    will-change: transform, opacity, filter;
  }
  
  .text.active span {
    opacity: 1;
    transform: translateY(0) rotateX(0deg);
    filter: blur(0);
  }

  /* NEW: Prediction Button Styles */
  .prediction-container {
    margin-top: 2rem;
    position: relative;
    z-index: 10;
    opacity: 0;
    transition: opacity 1s ease 1s; /* Fades in after the text */
  }

  .final-message.active .prediction-container {
    opacity: 1;
  }

  .magic-btn {
    background: rgba(255, 215, 0, 0.1);
    border: 1px solid rgba(255, 215, 0, 0.5);
    color: #ffd700;
    padding: 15px 35px;
    font-family: 'Inter', sans-serif;
    font-size: 1.1rem;
    border-radius: 50px;
    cursor: pointer;
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.1);
  }

  .magic-btn:hover {
    background: rgba(255, 215, 0, 0.25);
    box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
    transform: scale(1.05);
  }

  .prediction-output {
    margin-top: 25px;
    font-size: clamp(1.2rem, 3vw, 1.6rem);
    color: #fff;
    min-height: 1.6em;
    font-weight: 300;
    text-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
    transition: opacity 0.5s ease;
  }
  
  #treeSection {
    background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0a 70%);
    position: relative;
    overflow: hidden;
  }
  
  .tree-hint {
    position: absolute;
    bottom: 50px;
    left: 50%;
    transform: translateX(-50%);
    color: rgba(255, 215, 0, 0.8);
    font-size: 1.2rem;
    font-weight: 300;
    text-align: center;
    z-index: 10;
    animation: hintFade 3s ease-in-out infinite;
    pointer-events: none;
  }
  
  @keyframes hintFade {
    0%, 100% { opacity: 0.4; }
    50% { opacity: 1; }
  }
  
  canvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: none;
    touch-action: none;
  }
  
  .cursor {
    width: 30px;
    height: 30px;
    position: fixed;
    pointer-events: none;
    z-index: 9999;
    transition: all 0.15s ease;
    will-change: transform;
  }
  
  .cursor::before {
    content: '‚≠ê';
    font-size: 24px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    filter: drop-shadow(0 0 10px rgba(255, 215, 0, 1)) drop-shadow(0 0 20px rgba(255, 215, 0, 0.8));
    animation: starPulse 1.5s ease-in-out infinite;
  }
  
  .cursor.active::before {
    font-size: 32px;
    filter: drop-shadow(0 0 20px rgba(255, 215, 0, 1)) drop-shadow(0 0 40px rgba(255, 215, 0, 1)) drop-shadow(0 0 60px rgba(255, 100, 0, 0.8));
    animation: starPulse 0.5s ease-in-out infinite;
  }
  
  @keyframes starPulse {
    0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
    50% { transform: translate(-50%, -50%) scale(1.2) rotate(180deg); }
  }
  
  .final-message {
    background: #0a0a0a;
    position: relative;
  }
  
  .final-message::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: 
      radial-gradient(circle at 20% 50%, rgba(255, 215, 0, 0.05) 0%, transparent 50%),
      radial-gradient(circle at 80% 50%, rgba(46, 125, 50, 0.05) 0%, transparent 50%);
    animation: bgShift 10s ease-in-out infinite;
  }
  
  @keyframes bgShift {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
  }
  
  .snow-overlay {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none;
    z-index: 9999;
  }
  
  .snowflake {
    position: absolute;
    background: white;
    border-radius: 50%;
    opacity: 0.8;
    animation: fall linear forwards;
  }
  
  @keyframes fall {
    to {
      transform: translateY(100vh) translateX(var(--drift));
      opacity: 0;
    }
  }
  
  @media (pointer: coarse) {
    canvas { cursor: default; }
    .cursor { display: none; }
    .text { font-size: clamp(1.5rem, 5vw, 3rem); }
  }
</style>
</head>
<body>

<div class="cursor"></div>
<div class="snow-overlay" id="snowOverlay"></div>

<section>
  <div class="text" data-text="Hey"></div>
</section>

<section>
  <div class="text" data-text="I made this just for you"></div>
</section>

<section>
  <div class="text" data-text="Each part appears intentionally|like a little surprise"></div>
</section>

<section>
  <div class="text" data-text="Keep scrolling...|something magical awaits"></div>
</section>

<section id="treeSection">
  <canvas id="treeCanvas"></canvas>
  <div class="tree-hint">Click anywhere for fireworks</div>
</section>

<section class="final-message">
  <div class="text" data-text="Merry Christmas‚ù§Ô∏è||May your holidays sparkle with joy" style="position: relative; z-index: 1;"></div>
  <div class="prediction-container">
    <button id="predictBtn" class="magic-btn">Reveal My 2026 Prediction</button>
    <div id="predictionText" class="prediction-output"></div>
  </div>
</section>

<script>
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  const STAR_COUNT = isMobile ? 300 : 500;
  const PARTICLE_LIMIT = isMobile ? 50 : 100;
  
  // Split text into characters
  document.querySelectorAll('.text[data-text]').forEach(el => {
    const text = el.getAttribute('data-text');
    const lines = text.split('|');
    el.innerHTML = '';
    
    lines.forEach((line, lineIndex) => {
      if (lineIndex > 0) el.appendChild(document.createElement('br'));
      const chars = line.split('');
      chars.forEach((char, i) => {
        const span = document.createElement('span');
        span.textContent = char === ' ' ? '\u00A0' : char;
        span.style.transitionDelay = `${(lineIndex * chars.length + i) * 0.025}s`;
        el.appendChild(span);
      });
    });
  });
  
  // Custom cursor
  const cursor = document.querySelector('.cursor');
  let mouseX = 0, mouseY = 0, cursorX = 0, cursorY = 0;
  
  document.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
  });
  
  function animateCursor() {
    cursorX += (mouseX - cursorX) * 0.2;
    cursorY += (mouseY - cursorY) * 0.2;
    cursor.style.left = cursorX + 'px';
    cursor.style.top = cursorY + 'px';
    requestAnimationFrame(animateCursor);
  }
  if (!isMobile) animateCursor();
  
  // Intersection Observer
  const observerOptions = { threshold: 0.5 };
  let scrollLockTimeout;
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting && entry.intersectionRatio >= 0.5) {
        if (!entry.target.classList.contains('active')) {
          entry.target.classList.add('active');
          document.body.style.overflow = 'hidden';
          clearTimeout(scrollLockTimeout);
          scrollLockTimeout = setTimeout(() => { document.body.style.overflow = ''; }, 1000);
        }
      }
    });
  }, observerOptions);
  document.querySelectorAll('.text, .final-message').forEach(el => observer.observe(el));
  
  // Prediction Logic
  const predictions = [
    "2026: A year of unexpected travel and new horizons. ‚úàÔ∏è",
    "2026: Your hard work turns into a golden opportunity. üåü",
    "2026: A year of deep connections and meaningful laughter. ‚ú®",
    "2026: You will master a skill you haven't started yet. üìö",
    "2026: A season of peace, health, and total clarity. üåø",
    "2026: Your creativity will reach levels you never imagined. üé®",
    "2026: A surprise blessing is heading your way. üéÅ"
  ];

  document.getElementById('predictBtn').addEventListener('click', (e) => {
    const rect = e.target.getBoundingClientRect();
    // Reusing your createExplosion function
    createExplosion(rect.left + rect.width/2, rect.top + rect.height/2, 25);
    
    const output = document.getElementById('predictionText');
    output.style.opacity = 0;
    setTimeout(() => {
      output.textContent = predictions[Math.floor(Math.random() * predictions.length)];
      output.style.opacity = 1;
    }, 200);
  });

  // Christmas Tree Canvas
  const canvas = document.getElementById('treeCanvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  let stars = [], mouse = { x: -1000, y: -1000 }, particles = [], animationId;
  
  function resizeCanvas() {
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.scale(dpr, dpr);
    initStars();
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();
  
  function initStars() {
    stars = [];
    const centerX = window.innerWidth / 2, centerY = window.innerHeight / 2;
    const treeHeight = Math.min(window.innerHeight * 0.8, 650);
    const treeWidth = treeHeight * 0.85;
    for (let i = 0; i < STAR_COUNT; i++) {
      const progress = i / STAR_COUNT;
      const y = centerY - treeHeight / 2 + progress * treeHeight;
      const radiusAtY = (progress * treeWidth) / 2;
      const theta = Math.random() * Math.PI * 2;
      const radius = Math.random() * radiusAtY;
      const x = centerX + Math.cos(theta) * radius;
      const z = Math.sin(theta) * radius;
      stars.push({
        x, y, baseX: x, baseY: y, baseZ: z, baseRadius: radius, baseTheta: theta,
        angle: Math.random() * Math.PI * 2, orbitRadius: 25 + Math.random() * 15,
        speed: 0.002 + Math.random() * 0.003, radius: 1.2 + Math.random() * 2,
        hue: 40 + Math.random() * 20, brightness: 0.7 + Math.random() * 0.3,
        vx: 0, vy: 0, ovx: 0, ovy: 0, rotationAngle: 0
      });
    }
    stars.push({
      x: centerX, y: centerY - treeHeight / 2 - 35, baseX: centerX, baseY: centerY - treeHeight / 2 - 35,
      baseZ: 0, baseRadius: 0, baseTheta: 0, angle: 0, orbitRadius: 0, speed: 0.008,
      radius: 9, hue: 50, brightness: 1, isTop: true, vx: 0, vy: 0, ovx: 0, ovy: 0, rotationAngle: 0
    });
  }
  
  function createExplosion(x, y, count = 25) {
    if (particles.length > PARTICLE_LIMIT) return;
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count;
      const velocity = 3 + Math.random() * 3;
      particles.push({
        x, y, vx: Math.cos(angle) * velocity, vy: Math.sin(angle) * velocity,
        life: 1, hue: Math.random() * 360, size: 2 + Math.random() * 3
      });
    }
  }
  
  function handleInteraction(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    mouse.x = clientX - rect.left;
    mouse.y = clientY - rect.top;
    stars.forEach(star => {
      const dx = star.x - mouse.x, dy = star.y - mouse.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 180 && dist > 15) {
        const force = (1 - dist / 180);
        star.ovx = (-dy / dist) * force * 7;
        star.ovy = (dx / dist) * force * 7;
        star.vx += (dx / dist) * force * 2.5;
        star.vy += (dy / dist) * force * 2.5;
      } else { star.ovx *= 0.94; star.ovy *= 0.94; }
    });
  }
  
  canvas.addEventListener('mousemove', (e) => {
    handleInteraction(e.clientX, e.clientY);
    cursor.classList.add('active');
  });
  canvas.addEventListener('mouseleave', () => {
    mouse = { x: -1000, y: -1000 };
    cursor.classList.remove('active');
  });
  canvas.addEventListener('click', (e) => {
    createExplosion(e.clientX - canvas.getBoundingClientRect().left, e.clientY - canvas.getBoundingClientRect().top, 30);
  });
  
  function drawStars(currentTime) {
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life -= 0.018;
      if (p.life <= 0) { particles.splice(i, 1); continue; }
      ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      ctx.fillStyle = `hsla(${p.hue}, 100%, 60%, ${p.life})`;
      ctx.fill();
    }
    const centerX = window.innerWidth / 2, globalRotation = Date.now() * 0.0003;
    stars.forEach(star => {
      if (!star.isTop) {
        star.rotationAngle = star.baseTheta + globalRotation;
        const rX = Math.cos(star.rotationAngle) * star.baseRadius;
        const rZ = Math.sin(star.rotationAngle) * star.baseRadius;
        star.baseX = centerX + rX;
        star.currentDepth = rZ;
        star.depthScale = 0.5 + (rZ / (window.innerHeight * 0.4) + 1) * 0.25;
      }
    });
    const sortedStars = [...stars].sort((a, b) => (a.currentDepth || 0) - (b.currentDepth || 0));
    sortedStars.forEach(star => {
      star.angle += star.speed;
      const tX = star.baseX + Math.cos(star.angle) * star.orbitRadius;
      const tY = star.baseY + Math.sin(star.angle) * star.orbitRadius * 0.3;
      star.x += star.ovx + star.vx; star.y += star.ovy + star.vy;
      star.vx += (tX - star.x) * 0.02; star.vy += (tY - star.y) * 0.02;
      star.vx *= 0.88; star.vy *= 0.88;
      ctx.beginPath();
      const finalRadius = star.radius * (star.depthScale || 1);
      ctx.arc(star.x, star.y, finalRadius, 0, Math.PI * 2);
      if (star.isTop) {
        const pulse = Math.sin(Date.now() * 0.004) * 0.3 + 0.7;
        ctx.fillStyle = `hsla(50, 100%, ${75 * pulse}%, ${pulse})`;
        ctx.shadowBlur = 40 * pulse; ctx.shadowColor = 'gold';
      } else {
        const alpha = 0.5 + (star.depthScale || 1) * 0.5;
        ctx.fillStyle = `hsla(${star.hue}, 100%, ${50 + star.brightness * 25}%, ${alpha})`;
      }
      ctx.fill(); ctx.shadowBlur = 0;
    });
    requestAnimationFrame(drawStars);
  }
  drawStars();
  
  function createSnow() {
    const snowflake = document.createElement('div');
    snowflake.className = 'snowflake';
    const size = 3 + Math.random() * 5;
    snowflake.style.width = size + 'px'; snowflake.style.height = size + 'px';
    snowflake.style.left = Math.random() * 100 + '%';
    snowflake.style.setProperty('--drift', (Math.random() - 0.5) * 100 + 'px');
    snowflake.style.animationDuration = (3 + Math.random() * 4) + 's';
    document.getElementById('snowOverlay').appendChild(snowflake);
    setTimeout(() => snowflake.remove(), 7000);
  }
  setInterval(createSnow, 150);
</script>
</body>
</html>
