<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Scrolling Christmas Surprise</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;700&display=swap" rel="stylesheet">
<style>
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  html {
    scroll-behavior: smooth;
    scroll-snap-type: y mandatory;
    height: 100%;
    overflow-y: scroll;
  }

  body {
    font-family: 'Inter', sans-serif;
    background: #0a0a0a;
    color: white;
    overflow-x: hidden;
    margin: 0;
  }

  /* Custom Scrollbar for nicer look */
  ::-webkit-scrollbar { width: 8px; }
  ::-webkit-scrollbar-track { background: #0a0a0a; }
  ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }

  section {
    height: 100vh;
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 20px;
    position: relative;
    scroll-snap-align: start;
    scroll-snap-stop: always;
    overflow: hidden; /* Prevents overflow from animations */
  }

  /* Provide semantic heading styles */
  h1, h2 {
    font-weight: 500;
    margin-bottom: 0.5rem;
  }

  .text {
    max-width: 800px;
    font-size: clamp(2rem, 5vw, 3.5rem);
    font-weight: 500;
    line-height: 1.4;
    z-index: 2;
    pointer-events: none; /* Allows clicking through text */
  }

  .text span {
    display: inline-block;
    opacity: 0;
    transform: translateY(60px) rotateX(-90deg);
    filter: blur(10px);
    transition: all 0.8s cubic-bezier(0.16, 1, 0.3, 1);
    will-change: transform, opacity, filter;
  }

  .text.active span {
    opacity: 1;
    transform: translateY(0) rotateX(0deg);
    filter: blur(0);
  }

  /* Emoji Section */
  .emoji-section {
    font-size: clamp(8rem, 20vw, 15rem);
    opacity: 0;
    transform: scale(0.5) rotate(-180deg);
    transition: all 1.2s cubic-bezier(0.34, 1.56, 0.64, 1);
  }
  .emoji-section.active {
    opacity: 1;
    transform: scale(1) rotate(0deg);
  }

  /* Tree Section */
  #treeSection {
    background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0a 70%);
    position: relative;
  }

  .tree-hint {
    position: absolute;
    bottom: 10%;
    left: 50%;
    transform: translateX(-50%);
    color: rgba(255, 215, 0, 0.6);
    font-size: 1rem;
    font-weight: 300;
    letter-spacing: 1px;
    pointer-events: none;
    animation: pulse 2s infinite;
  }

  @keyframes pulse { 0%, 100% { opacity: 0.4; } 50% { opacity: 1; } }

  canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: block;
    /* Important: allows scrolling on mobile UNLESS touching tree directly */
    touch-action: pan-y;
  }

  /* Custom Cursor - centered via transform */
  .cursor {
    width: 20px;
    height: 20px;
    position: fixed;
    pointer-events: none;
    z-index: 9999;
    mix-blend-mode: difference;
    transition: transform 0.12s;
    left: 0;
    top: 0;
    transform: translate(-50%, -50%) scale(1);
  }

  .cursor::after {
    content: '';
    position: absolute;
    top: 50%; left: 50%;
    width: 100%; height: 100%;
    background: rgba(255, 215, 0, 0.8);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
  }

  .cursor.active { transform: translate(-50%, -50%) scale(2.5); }
  
  .final-message::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: radial-gradient(circle at 50% 50%, rgba(255, 215, 0, 0.03) 0%, transparent 60%);
    animation: glow 5s infinite alternate;
  }
  @keyframes glow { from { opacity: 0.5; } to { opacity: 1; } }

  /* Snow Effect */
  .snow-container {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 1;
  }
  .snowflake {
    position: absolute;
    background: white;
    border-radius: 50%;
    opacity: 0.8;
    animation: fall linear forwards;
  }
  @keyframes fall {
    to { transform: translateY(105vh); }
  }

  @media (hover: none) {
    .cursor { display: none; }
  }

  /* Respect user's reduced motion preference */
  @media (prefers-reduced-motion: reduce) {
    html, * {
      animation: none !important;
      transition: none !important;
      scroll-behavior: auto !important;
    }
    .text span { transition: none; opacity: 1; transform: none; filter: none; }
    .emoji-section { transition: none; opacity: 1; transform: none; }
  }
</style>
</head>
<body>

<div class="cursor" id="customCursor" aria-hidden="true"></div>
<div class="snow-container" id="snowContainer" aria-hidden="true"></div>

<section>
  <h1 class="text" data-text="Hey"></h1>
</section>

<section>
  <h2 class="text" data-text="I made this just for you"></h2>
</section>

<section>
  <div class="text" data-text="Each part appears intentionally |like a little surprise"></div>
</section>

<section>
  <div class="emoji-section text" aria-hidden="true">ðŸ˜Š</div>
</section>

<section>
  <div class="text" data-text="Keep scrolling...|something magical awaits"></div>
</section>

<section id="treeSection" aria-label="Interactive Christmas tree section">
  <canvas id="treeCanvas" role="img" aria-label="Interactive Christmas tree; hover or tap to create sparkles"></canvas>
  <div class="tree-hint">Tap or hover to interact</div>
</section>

<section class="final-message">
  <div class="text" data-text="Merry Christmas â¤ï¸||May your holidays sparkle with joy"></div>
</section>

<script>
  // 1. Mobile Detection & Config
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  // You requested to keep the star count at 600
  const STAR_COUNT = 600;

  // Reduced-motion preference
  const reduceMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  // 2. Text Split & Reveal Logic
  document.querySelectorAll('.text[data-text]').forEach(el => {
    const text = el.getAttribute('data-text') || '';
    const lines = text.split('|');
    el.innerHTML = '';
    
    lines.forEach((line, lineIndex) => {
      if (lineIndex > 0) el.appendChild(document.createElement('br'));
      
      const chars = line.split('');
      chars.forEach((char, i) => {
        const span = document.createElement('span');
        span.textContent = char === ' ' ? '\u00A0' : char;
        // Stagger delay calculation
        if (!reduceMotion) {
          span.style.transitionDelay = `${(lineIndex * 10 + i) * 0.04}s`;
        } else {
          span.style.transitionDelay = '0s';
        }
        el.appendChild(span);
      });
    });
  });

  // 3. Scroll Observer
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('active');
      } else {
        entry.target.classList.remove('active');
      }
    });
  }, { threshold: 0.4 });

  document.querySelectorAll('.text, .emoji-section').forEach(el => observer.observe(el));

  // 4. Custom Cursor
  const cursor = document.getElementById('customCursor');
  let mouseX = -100, mouseY = -100;
  let cursorX = -100, cursorY = -100;
  let showCursor = !isMobile;

  document.addEventListener('mousemove', e => {
    mouseX = e.clientX;
    mouseY = e.clientY;
  });

  function updateCursor() {
    // Smooth Lerp
    cursorX += (mouseX - cursorX) * 0.2;
    cursorY += (mouseY - cursorY) * 0.2;
    cursor.style.left = `${cursorX}px`;
    cursor.style.top = `${cursorY}px`;
    requestAnimationFrame(updateCursor);
  }
  if (showCursor) updateCursor();

  // 5. Canvas Tree Animation
  const canvas = document.getElementById('treeCanvas');
  const ctx = canvas.getContext('2d'); // keep alpha for CSS background
  let stars = [];
  let particles = [];
  let w = 0, h = 0;
  let mouse = { x: -1000, y: -1000 };

  // DPR-aware resize and immediate initialization
  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const cssW = window.innerWidth;
    const cssH = window.innerHeight;
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    // scale so drawing code can use CSS pixels coordinates
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    w = cssW;
    h = cssH;
    initStars();
  }
  window.addEventListener('resize', resize);
  // Call resize synchronously before starting animations
  resize();

  function initStars() {
    stars = [];
    const treeH = Math.min(h * 0.8, 600);
    const treeW = treeH * 0.6;
    
    for(let i=0; i<STAR_COUNT; i++) {
      const progress = i / STAR_COUNT;
      const y = (h/2 - treeH/2) + progress * treeH;
      const radiusAtY = progress * treeW;
      
      // Cylindrical coordinates for 3D effect
      const angle = Math.random() * Math.PI * 2;
      const dist = Math.random() * radiusAtY;
      
      stars.push({
        baseX: Math.cos(angle) * dist, // Relative to center
        baseZ: Math.sin(angle) * dist, // Depth
        y: y,
        angle: angle,
        speed: 0.005 + Math.random() * 0.01,
        color: `hsl(${40 + Math.random()*20}, 100%, ${60 + Math.random()*40}%)`,
        size: 0.5 + Math.random() * 2,
        
        // Physics vars
        x: 0, z: 0, 
        vx: 0, vy: 0, vz: 0
      });
    }
    
    // Top Star
    stars.push({
      isTop: true,
      x: 0, y: (h/2 - treeH/2) - 15, z: 0,
      baseX: 0, baseZ: 0,
      angle: 0, speed: 0,
      color: '#ffd700', size: 10
    });
  }

  // Interaction Handler
  function handleInput(x, y) {
    const rect = canvas.getBoundingClientRect();
    mouse.x = x - rect.left;
    mouse.y = y - rect.top;
    
    if (showCursor) cursor.classList.add('active');
    
    // Create sparkles on movement (throttled and disabled for reduced motion)
    if (!reduceMotion && particles.length < 200 && Math.random() > 0.8) {
      createSparkle(mouse.x, mouse.y);
    }
  }

  canvas.addEventListener('mousemove', e => handleInput(e.clientX, e.clientY));
  canvas.addEventListener('touchmove', e => {
    // If you want to block page scroll while touching tree, uncomment the next line.
    // e.preventDefault();
    handleInput(e.touches[0].clientX, e.touches[0].clientY);
  }, {passive: true});

  canvas.addEventListener('mouseleave', () => {
    mouse.x = -1000;
    if (showCursor) cursor.classList.remove('active');
  });

  function createSparkle(x, y) {
    // Throttle create rate by bounding particle count
    if (particles.length > 400) return;
    particles.push({
      x, y,
      vx: (Math.random()-0.5) * 4,
      vy: (Math.random()-0.5) * 4,
      life: 1,
      color: `hsl(${Math.random()*360}, 100%, 70%)`
    });
  }

  // Animation loop control
  let rafId = null;
  let isAnimating = false;

  function animate() {
    // loop guard (shouldn't start multiple loops)
    if (rafId !== null) cancelAnimationFrame(rafId);

    // Use a closure-based loop
    function loop() {
      // Clear rect (use CSS pixels)
      ctx.clearRect(0, 0, w, h);
      
      const cx = w / 2;
      // Rotate tree slowly unless reduced motion
      const time = reduceMotion ? 0 : Date.now() * 0.0005;

      // 1. Draw Sparkles (skip if reduced motion)
      if (!reduceMotion) {
        for(let i=particles.length-1; i>=0; i--) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.life -= 0.03;
          if(p.life <= 0) { particles.splice(i, 1); continue; }
          
          ctx.beginPath();
          ctx.fillStyle = p.color;
          ctx.globalAlpha = p.life;
          ctx.arc(p.x, p.y, 2 * p.life, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }

      // 2. Draw Stars (Pseudo 3D)
      for (let si = 0; si < stars.length; si++) {
        const star = stars[si];
        if (star.isTop) {
          ctx.save();
          ctx.shadowBlur = 20;
          ctx.shadowColor = 'gold';
          ctx.fillStyle = star.color;
          ctx.beginPath();
          ctx.arc(cx, star.y, star.size, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
          continue;
        }

        // Rotate around Y axis
        const cos = Math.cos(time + star.angle);
        const sin = Math.sin(time + star.angle);
        
        // 3D projection
        let x = star.baseX * cos - star.baseZ * sin;
        let z = star.baseZ * cos + star.baseX * sin;
        
        // Perspective scale
        const scale = 300 / (300 + z + 200); // Simple perspective
        const screenX = cx + x * scale;
        const screenY = star.y * scale; // Also scale Y for perspective height

        // Mouse Repulsion (2D approximation) with zero-distance guard
        const dx = screenX - mouse.x;
        const dy = screenY - mouse.y;
        const dist = Math.sqrt(dx*dx + dy*dy) || 1; // guard: if zero -> 1

        if (!reduceMotion && dist < 100) {
          const force = (100 - dist) / 100;
          const nx = dx / dist;
          const ny = dy / dist;
          star.vx += nx * force * 5;
          star.vy += ny * force * 5;
        }

        // Physics Return / damping
        star.vx *= 0.9;
        star.vy *= 0.9;
        star.vx -= star.vx * 0.1;
        star.vy -= star.vy * 0.1;

        const drawX = screenX + star.vx;
        const drawY = screenY + star.vy;
        const drawSize = Math.max(0.1, star.size * scale);

        // Draw star
        ctx.fillStyle = star.color;
        ctx.globalAlpha = scale; // Fade distant stars
        ctx.beginPath();
        ctx.arc(drawX, drawY, drawSize, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      rafId = requestAnimationFrame(loop);
    }

    loop();
  }

  // Start animation now that resize() ran
  // Respect reduced motion: still draw static stars but avoid heavy sparkles if reduceMotion
  if (!document.hidden) {
    animate();
  }

  // Pause/Resume on page visibility to save resources
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
    } else {
      if (!rafId) animate();
    }
  });

  // 6. Falling Snow (DOM for performance on mobile)
  const snowContainer = document.getElementById('snowContainer');
  let snowTimer = null;
  function addSnowflake() {
    const el = document.createElement('div');
    el.className = 'snowflake';
    el.style.left = Math.random() * 100 + '%';
    el.style.width = el.style.height = (Math.random() * 4 + 2) + 'px';
    el.style.animationDuration = (Math.random() * 3 + 2) + 's';
    el.style.opacity = Math.random();
    
    snowContainer.appendChild(el);
    setTimeout(() => el.remove(), 5000);
  }

  // Adaptive snow frequency (lighter on mobile)
  const snowIntervalMs = isMobile ? 350 : 200;
  function startSnow() {
    if (snowTimer) clearInterval(snowTimer);
    snowTimer = setInterval(addSnowflake, snowIntervalMs);
  }
  function stopSnow() {
    if (snowTimer) { clearInterval(snowTimer); snowTimer = null; }
  }
  // Start snow only when visible to save CPU
  if (!document.hidden) startSnow();
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) stopSnow(); else startSnow();
  });

  // Accessibility: pause animations if reduced-motion is requested
  if (reduceMotion) {
    // Stop particle generation and stop snow for reduced motion to be considerate
    stopSnow();
    particles = [];
  }
</script>
</body>
</html>
