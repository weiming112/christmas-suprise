<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Scrolling Christmas Surprise</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;700&display=swap" rel="stylesheet">
<style>
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  html {
    scroll-behavior: smooth;
    scroll-snap-type: y mandatory;
    height: 100%;
    overflow-y: scroll;
  }

  body {
    font-family: 'Inter', sans-serif;
    background: #0a0a0a;
    color: white;
    overflow-x: hidden;
    margin: 0;
  }

  /* Custom Scrollbar for nicer look */
  ::-webkit-scrollbar { width: 8px; }
  ::-webkit-scrollbar-track { background: #0a0a0a; }
  ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }

  section {
    height: 100vh;
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 20px;
    position: relative;
    scroll-snap-align: start;
    scroll-snap-stop: always;
    overflow: hidden; /* Prevents overflow from animations */
  }

  .text {
    max-width: 800px;
    font-size: clamp(2rem, 5vw, 3.5rem);
    font-weight: 500;
    line-height: 1.4;
    z-index: 2;
    pointer-events: none; /* Allows clicking through text */
  }

  .text span {
    display: inline-block;
    opacity: 0;
    transform: translateY(60px) rotateX(-90deg);
    filter: blur(10px);
    transition: all 0.8s cubic-bezier(0.16, 1, 0.3, 1);
    will-change: transform, opacity, filter;
  }

  .text.active span {
    opacity: 1;
    transform: translateY(0) rotateX(0deg);
    filter: blur(0);
  }

  /* Emoji Section */
  .emoji-section {
    font-size: clamp(8rem, 20vw, 15rem);
    opacity: 0;
    transform: scale(0.5) rotate(-180deg);
    transition: all 1.2s cubic-bezier(0.34, 1.56, 0.64, 1);
  }
  .emoji-section.active {
    opacity: 1;
    transform: scale(1) rotate(0deg);
  }

  /* Tree Section */
  #treeSection {
    background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0a 70%);
    position: relative;
  }

  .tree-hint {
    position: absolute;
    bottom: 10%;
    left: 50%;
    transform: translateX(-50%);
    color: rgba(255, 215, 0, 0.6);
    font-size: 1rem;
    font-weight: 300;
    letter-spacing: 1px;
    pointer-events: none;
    animation: pulse 2s infinite;
  }

  @keyframes pulse { 0%, 100% { opacity: 0.4; } 50% { opacity: 1; } }

  canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: block;
    /* Important: allows scrolling on mobile UNLESS touching tree directly */
    touch-action: pan-y; 
  }

  /* Custom Cursor */
  .cursor {
    width: 20px;
    height: 20px;
    position: fixed;
    pointer-events: none;
    z-index: 9999;
    mix-blend-mode: difference;
    transition: transform 0.1s;
  }

  .cursor::after {
    content: '';
    position: absolute;
    top: 50%; left: 50%;
    width: 100%; height: 100%;
    background: rgba(255, 215, 0, 0.8);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
  }

  .cursor.active { transform: scale(2.5); }
  
  .final-message::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: radial-gradient(circle at 50% 50%, rgba(255, 215, 0, 0.03) 0%, transparent 60%);
    animation: glow 5s infinite alternate;
  }
  @keyframes glow { from { opacity: 0.5; } to { opacity: 1; } }

  /* Snow Effect */
  .snow-container {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 1;
  }
  .snowflake {
    position: absolute;
    background: white;
    border-radius: 50%;
    opacity: 0.8;
    animation: fall linear forwards;
  }
  @keyframes fall {
    to { transform: translateY(105vh); }
  }

  @media (hover: none) {
    .cursor { display: none; }
  }
</style>
</head>
<body>

<div class="cursor"></div>
<div class="snow-container" id="snowContainer"></div>

<section>
  <div class="text" data-text="Hey"></div>
</section>

<section>
  <div class="text" data-text="I made this just for you"></div>
</section>

<section>
  <div class="text" data-text="Each part appears intentionally|like a little surprise"></div>
</section>

<section>
  <div class="emoji-section text">ðŸ˜Š</div>
</section>

<section>
  <div class="text" data-text="Keep scrolling...|something magical awaits"></div>
</section>

<section id="treeSection">
  <canvas id="treeCanvas"></canvas>
  <div class="tree-hint">Tap or hover to interact âœ¨</div>
</section>

<section class="final-message">
  <div class="text" data-text="Merry Christmas ðŸŽ„â¤ï¸||May your holidays sparkle with joy"></div>
</section>

<script>
  // 1. Mobile Detection & Config
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  const STAR_COUNT = isMobile ? 300 : 600; 

  // 2. Text Split & Reveal Logic
  document.querySelectorAll('.text[data-text]').forEach(el => {
    const text = el.getAttribute('data-text');
    const lines = text.split('|');
    el.innerHTML = '';
    
    lines.forEach((line, lineIndex) => {
      if (lineIndex > 0) el.appendChild(document.createElement('br'));
      
      const chars = line.split('');
      chars.forEach((char, i) => {
        const span = document.createElement('span');
        span.textContent = char === ' ' ? '\u00A0' : char;
        // Stagger delay calculation
        span.style.transitionDelay = `${(lineIndex * 10 + i) * 0.04}s`;
        el.appendChild(span);
      });
    });
  });

  // 3. Scroll Observer (REMOVED THE BUGGY SCROLL LOCK)
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('active');
      } else {
        entry.target.classList.remove('active');
      }
    });
  }, { threshold: 0.4 });

  document.querySelectorAll('.text, .emoji-section').forEach(el => observer.observe(el));

  // 4. Custom Cursor
  const cursor = document.querySelector('.cursor');
  let mouseX = -100, mouseY = -100;
  let cursorX = -100, cursorY = -100;

  document.addEventListener('mousemove', e => {
    mouseX = e.clientX;
    mouseY = e.clientY;
  });

  function updateCursor() {
    // Smooth Lerp
    cursorX += (mouseX - cursorX) * 0.2;
    cursorY += (mouseY - cursorY) * 0.2;
    cursor.style.left = `${cursorX}px`;
    cursor.style.top = `${cursorY}px`;
    requestAnimationFrame(updateCursor);
  }
  if (!isMobile) updateCursor();

  // 5. Canvas Tree Animation
  const canvas = document.getElementById('treeCanvas');
  const ctx = canvas.getContext('2d'); // Removed alpha:false to let gradient show
  let stars = [];
  let particles = [];
  let w, h;
  let mouse = { x: -1000, y: -1000 };

  function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
    initStars();
  }
  window.addEventListener('resize', resize);
  setTimeout(resize, 100); // Initial call

  function initStars() {
    stars = [];
    const treeH = Math.min(h * 0.8, 600);
    const treeW = treeH * 0.6;
    
    for(let i=0; i<STAR_COUNT; i++) {
      const progress = i / STAR_COUNT;
      const y = (h/2 - treeH/2) + progress * treeH;
      const radiusAtY = progress * treeW;
      
      // Cylindrical coordinates for 3D effect
      const angle = Math.random() * Math.PI * 2;
      const dist = Math.random() * radiusAtY;
      
      stars.push({
        baseX: Math.cos(angle) * dist, // Relative to center
        baseZ: Math.sin(angle) * dist, // Depth
        y: y,
        angle: angle,
        speed: 0.005 + Math.random() * 0.01,
        color: `hsl(${40 + Math.random()*20}, 100%, ${60 + Math.random()*40}%)`,
        size: 0.5 + Math.random() * 2,
        
        // Physics vars
        x: 0, z: 0, 
        vx: 0, vy: 0, vz: 0
      });
    }
    
    // Top Star
    stars.push({
      isTop: true,
      x: 0, y: (h/2 - treeH/2) - 15, z: 0,
      baseX: 0, baseZ: 0,
      angle: 0, speed: 0,
      color: '#ffd700', size: 10
    });
  }

  // Interaction Handler
  function handleInput(x, y) {
    const rect = canvas.getBoundingClientRect();
    mouse.x = x - rect.left;
    mouse.y = y - rect.top;
    
    cursor.classList.add('active');
    
    // Create sparkles on movement
    if(Math.random() > 0.8) createSparkle(mouse.x, mouse.y);
  }

  canvas.addEventListener('mousemove', e => handleInput(e.clientX, e.clientY));
  canvas.addEventListener('touchmove', e => {
    // e.preventDefault(); // Uncomment if you want to block scrolling while touching tree
    handleInput(e.touches[0].clientX, e.touches[0].clientY);
  }, {passive: false});

  canvas.addEventListener('mouseleave', () => {
    mouse.x = -1000;
    cursor.classList.remove('active');
  });

  function createSparkle(x, y) {
    particles.push({
      x, y,
      vx: (Math.random()-0.5) * 4,
      vy: (Math.random()-0.5) * 4,
      life: 1,
      color: `hsl(${Math.random()*360}, 100%, 70%)`
    });
  }

  function animate() {
    // Clear rect to keep transparency for CSS background
    ctx.clearRect(0, 0, w, h);
    
    const cx = w/2;
    // Rotate entire tree slowly
    const time = Date.now() * 0.0005;

    // 1. Draw Sparkles
    for(let i=particles.length-1; i>=0; i--) {
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.life -= 0.03;
      if(p.life <= 0) { particles.splice(i, 1); continue; }
      
      ctx.beginPath();
      ctx.fillStyle = p.color;
      ctx.globalAlpha = p.life;
      ctx.arc(p.x, p.y, 2 * p.life, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // 2. Draw Stars (Pseudo 3D)
    stars.forEach(star => {
      if(star.isTop) {
        // Draw top star simply
        ctx.shadowBlur = 20;
        ctx.shadowColor = 'gold';
        ctx.fillStyle = star.color;
        ctx.beginPath();
        ctx.arc(cx, star.y, star.size, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
        return;
      }

      // Rotate around Y axis
      const cos = Math.cos(time + star.angle);
      const sin = Math.sin(time + star.angle);
      
      // 3D projection
      let x = star.baseX * cos - star.baseZ * sin;
      let z = star.baseZ * cos + star.baseX * sin;
      
      // Perspective scale
      const scale = 300 / (300 + z + 200); // Simple perspective
      const screenX = cx + x * scale;
      const screenY = star.y * scale; // Also scale Y for perspective height

      // Mouse Repulsion (2D approximation)
      const dx = screenX - mouse.x;
      const dy = screenY - mouse.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      
      if(dist < 100) {
        const force = (100 - dist) / 100;
        star.vx += (dx/dist) * force * 5;
        star.vy += (dy/dist) * force * 5;
      }

      // Physics Return
      star.vx *= 0.9;
      star.vy *= 0.9;
      star.vx -= (star.vx) * 0.1; 
      star.vy -= (star.vy) * 0.1; // Damping

      const drawX = screenX + star.vx;
      const drawY = screenY + star.vy;
      const drawSize = Math.max(0.1, star.size * scale);

      // Draw based on depth (Z)
      ctx.fillStyle = star.color;
      ctx.globalAlpha = scale; // Fade distant stars
      ctx.beginPath();
      ctx.arc(drawX, drawY, drawSize, 0, Math.PI*2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;

    requestAnimationFrame(animate);
  }
  animate();

  // 6. Falling Snow (DOM for performance on mobile)
  const snowContainer = document.getElementById('snowContainer');
  function addSnowflake() {
    const el = document.createElement('div');
    el.className = 'snowflake';
    el.style.left = Math.random() * 100 + '%';
    el.style.width = el.style.height = (Math.random() * 4 + 2) + 'px';
    el.style.animationDuration = (Math.random() * 3 + 2) + 's';
    el.style.opacity = Math.random();
    
    snowContainer.appendChild(el);
    setTimeout(() => el.remove(), 5000);
  }
  setInterval(addSnowflake, 200);

</script>
</body>
</html>
